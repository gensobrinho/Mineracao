const fetch = require("node-fetch");
const fs = require("fs");
require("dotenv").config();

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

if (!GITHUB_TOKEN) {
  console.error(
    "Erro: O token do GitHub n√£o foi encontrado. Certifique-se de que o arquivo .env cont√©m a vari√°vel GITHUB_TOKEN."
  );
  process.exit(1);
}

const csvPath = "repositorios_acessibilidade.csv";
const writeHeader = () => {
  if (!fs.existsSync(csvPath)) {
    fs.writeFileSync(
      csvPath,
      "Reposit√≥rio,Estrelas,AXE em Workflow,Pa11y em Workflow,Lighthouse em Workflow,Wave em Workflow,AXE em Depend√™ncia,Pa11y em Depend√™ncia,Lighthouse em Depend√™ncia,Wave em Depend√™ncia\n"
    );
  }
};

const appendToCSV = (row) => {
  const line = `${row.nameWithOwner},${row.stars},${row.axe_wf},${row.pa11y_wf},${row.lighthouse_wf},${row.wave_wf},${row.axe_dep},${row.pa11y_dep},${row.lighthouse_dep},${row.wave_dep}\n`;
  fs.appendFileSync(csvPath, line);
};

async function graphqlRequest(query, variables) {
  const response = await fetch("https://api.github.com/graphql", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${GITHUB_TOKEN}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ query, variables }),
  });

  if (!response.ok) {
    throw new Error(`Erro na solicita√ß√£o GraphQL: ${response.statusText}`);
  }

  const data = await response.json();
  return data.data;
}

async function fetchWithTimeout(url, options = {}, timeout = 30000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });
    clearTimeout(id);
    return response;
  } catch (error) {
    clearTimeout(id);
    throw error;
  }
}

async function checkWorkflows(owner, repo) {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/.github/workflows`;
  let axe = false,
    pa11y = false,
    lighthouse = false,
    wave = false;

  try {
    const response = await fetchWithTimeout(url, {
      headers: {
        Authorization: `Bearer ${GITHUB_TOKEN}`,
      },
    });

    if (response.status === 404) return { axe, pa11y, lighthouse, wave };
    if (!response.ok)
      throw new Error(`Erro ao buscar workflows: ${response.statusText}`);

    const files = await response.json();
    if (!Array.isArray(files)) return { axe, pa11y, lighthouse, wave };

    for (const file of files) {
      if (file.name.endsWith(".yml") || file.name.endsWith(".yaml")) {
        const workflowUrl = file.download_url;
        try {
          const workflowResponse = await fetchWithTimeout(
            workflowUrl,
            {},
            30000
          );
          if (!workflowResponse.ok) continue;
          const workflowContent = (await workflowResponse.text()).toLowerCase();
          if (workflowContent.includes("axe")) axe = true;
          if (workflowContent.includes("pa11y")) pa11y = true;
          if (workflowContent.includes("lighthouse")) lighthouse = true;
          if (workflowContent.includes("wave")) wave = true;
        } catch (error) {}
      }
    }
    return { axe, pa11y, lighthouse, wave };
  } catch (error) {
    return { axe, pa11y, lighthouse, wave };
  }
}

async function checkDependencies(owner, repo) {
  const dependencyFiles = [
    "package.json",
    "requirements.txt",
    "Gemfile",
    "composer.json",
  ];
  let axe = false,
    pa11y = false,
    lighthouse = false,
    wave = false;

  for (const fileName of dependencyFiles) {
    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${fileName}`;

    try {
      const response = await fetchWithTimeout(url, {
        headers: {
          Authorization: `Bearer ${GITHUB_TOKEN}`,
        },
      });

      if (response.status === 404) continue;
      if (!response.ok)
        throw new Error(
          `Erro ao buscar arquivo ${fileName}: ${response.statusText}`
        );

      const file = await response.json();
      if (file.encoding === "base64") {
        const content = Buffer.from(file.content, "base64")
          .toString("utf-8")
          .toLowerCase();
        if (content.includes("axe")) axe = true;
        if (content.includes("pa11y")) pa11y = true;
        if (content.includes("lighthouse")) lighthouse = true;
        if (content.includes("wave")) wave = true;
      }
    } catch (error) {}
  }
  return { axe, pa11y, lighthouse, wave };
}

const searchRepositoriesQuery = `
query($queryString: String!, $first: Int!, $after: String) {
  search(query: $queryString, type: REPOSITORY, first: $first, after: $after) {
    repositoryCount
    edges {
      node {
        ... on Repository {
          name
          owner { login }
          stargazerCount
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
`;

async function main() {
  writeHeader();
  let totalFound = 0;
  let totalAnalyzed = 0; // Contador total de reposit√≥rios analisados
  let after = null;
  const batchSize = 100; // Aumentado para mais efici√™ncia
  const processedRepos = new Set(); // Para evitar duplicados

  const queryStrings = [
    // üåü Reposit√≥rios mais populares em geral (ordenados por estrelas)
    "stars:>1000 sort:stars-desc",
    "stars:>500 sort:stars-desc",
    "stars:>100 sort:stars-desc",
    "stars:>50 sort:stars-desc",
    "stars:>10 sort:stars-desc",

    // üíª Reposit√≥rios populares por linguagem (mais propensos a ter web apps)
    "language:JavaScript stars:>100 sort:stars-desc",
    "language:TypeScript stars:>100 sort:stars-desc",
    "language:HTML stars:>50 sort:stars-desc",
    "language:CSS stars:>50 sort:stars-desc",

    // üåê Reposit√≥rios web populares por t√≥pico
    "topic:web stars:>50 sort:stars-desc",
    "topic:website stars:>50 sort:stars-desc",
    "topic:webapp stars:>50 sort:stars-desc",
    "topic:frontend stars:>50 sort:stars-desc",
    "topic:react stars:>100 sort:stars-desc",
    "topic:vue stars:>100 sort:stars-desc",
    "topic:angular stars:>100 sort:stars-desc",
    "topic:nodejs stars:>100 sort:stars-desc",

    // üì± Reposit√≥rios de aplica√ß√µes/plataformas populares
    "topic:app stars:>50 sort:stars-desc",
    "topic:application stars:>50 sort:stars-desc",
    "topic:platform stars:>50 sort:stars-desc",
    "topic:dashboard stars:>50 sort:stars-desc",
    "topic:ui stars:>50 sort:stars-desc",
    "topic:pwa stars:>50 sort:stars-desc",
  ];

  for (const queryString of queryStrings) {
    after = null;
    let queryFound = 0;
    let queryAnalyzed = 0;
    console.log(`\nüîç Buscando reposit√≥rios populares: "${queryString}"`);

    // Cada query roda at√© o final ou at√© 500 resultados por query
    while (queryFound < 500) {
      const variables = { queryString, first: batchSize, after };
      console.log(`üìä Processando lote de reposit√≥rios populares...`);
      console.log(`   Query: "${queryString.substring(0, 40)}..."`);
      console.log(
        `   Encontrados com ferramentas nesta query: ${queryFound} | Total geral: ${totalFound}`
      );

      try {
        const data = await graphqlRequest(searchRepositoriesQuery, variables);
        const edges = data.search.edges;
        if (edges.length === 0) break;

        console.log(
          `üìà Total de reposit√≥rios dispon√≠veis para esta query: ${
            data.search.repositoryCount || "N/A"
          }`
        );

        for (const edge of edges) {
          const repo = edge.node;
          const nameWithOwner = `${repo.owner.login}/${repo.name}`;

          // Pula se j√° foi processado
          if (processedRepos.has(nameWithOwner)) {
            console.log(`‚è≠Ô∏è  J√° processado anteriormente: ${nameWithOwner}`);
            continue;
          }

          // Adiciona reposit√≥rio para an√°lise (sem filtros - analisa TODOS os populares)
          processedRepos.add(nameWithOwner);
          queryAnalyzed++;
          totalAnalyzed++; // Incrementa contador global

          console.log(
            `üîç Analisando reposit√≥rio popular (${queryAnalyzed}): ${nameWithOwner} (${repo.stargazerCount}‚≠ê)`
          );

          const wf = await checkWorkflows(repo.owner.login, repo.name);
          const dep = await checkDependencies(repo.owner.login, repo.name);

          if (
            wf.axe ||
            wf.pa11y ||
            wf.lighthouse ||
            wf.wave ||
            dep.axe ||
            dep.pa11y ||
            dep.lighthouse ||
            dep.wave
          ) {
            appendToCSV({
              nameWithOwner,
              stars: repo.stargazerCount,
              axe_wf: wf.axe ? "Sim" : "N√£o",
              pa11y_wf: wf.pa11y ? "Sim" : "N√£o",
              lighthouse_wf: wf.lighthouse ? "Sim" : "N√£o",
              wave_wf: wf.wave ? "Sim" : "N√£o",
              axe_dep: dep.axe ? "Sim" : "N√£o",
              pa11y_dep: dep.pa11y ? "Sim" : "N√£o",
              lighthouse_dep: dep.lighthouse ? "Sim" : "N√£o",
              wave_dep: dep.wave ? "Sim" : "N√£o",
            });
            queryFound++;
            totalFound++;
            console.log(
              `‚úÖ üéØ ENCONTRADO! Repo com ferramentas de acessibilidade (${queryFound}/${totalFound}): ${nameWithOwner}`
            );
          } else {
            console.log(
              `‚ö™ N√£o possui ferramentas de acessibilidade: ${nameWithOwner}`
            );
          }
        }

        if (!data.search.pageInfo.hasNextPage) {
          console.log(
            `üìÑ Sem mais p√°ginas para query: "${queryString.substring(
              0,
              30
            )}..."`
          );
          break;
        }
        after = data.search.pageInfo.endCursor;

        // Pequena pausa para evitar rate limiting
        await new Promise((resolve) => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`‚ùå Erro na busca: ${error.message}`);
        await new Promise((resolve) => setTimeout(resolve, 2000));
        break;
      }
    }

    console.log(
      `üìä Query de reposit√≥rios populares finalizada: "${queryString.substring(
        0,
        40
      )}..."`
    );
    console.log(
      `   ‚îî‚îÄ Reposit√≥rios COM ferramentas encontrados: ${queryFound}`
    );
    console.log(`   ‚îî‚îÄ Reposit√≥rios populares analisados: ${queryAnalyzed}`);
    console.log(
      `   ‚îî‚îÄ Taxa de reposit√≥rios com acessibilidade: ${
        queryAnalyzed > 0 ? ((queryFound / queryAnalyzed) * 100).toFixed(1) : 0
      }%`
    );

    // Pausa entre queries
    await new Promise((resolve) => setTimeout(resolve, 2000));
  }

  console.log(
    `\nüéâ ===== AN√ÅLISE DE REPOSIT√ìRIOS POPULARES FINALIZADA ===== üéâ`
  );
  console.log(
    `üåü ESTRAT√âGIA: Buscar reposit√≥rios populares e verificar se usam ferramentas de acessibilidade`
  );
  console.log(
    `üî¢ Total de reposit√≥rios populares processados (todas as queries): ${totalAnalyzed}`
  );
  console.log(
    `üìä Reposit√≥rios √∫nicos analisados (sem duplicatas): ${processedRepos.size}`
  );
  console.log(
    `‚úÖ Reposit√≥rios populares que USAM ferramentas de acessibilidade: ${totalFound}`
  );
  console.log(
    `üìà Taxa de ado√ß√£o de acessibilidade (repos com ferramentas / √∫nicos): ${
      processedRepos.size > 0
        ? ((totalFound / processedRepos.size) * 100).toFixed(2)
        : 0
    }%`
  );
  console.log(
    `üéØ Taxa de efici√™ncia (√∫nicos / processados): ${
      totalAnalyzed > 0
        ? ((processedRepos.size / totalAnalyzed) * 100).toFixed(2)
        : 0
    }%`
  );
  console.log(
    `üîç Queries de reposit√≥rios populares executadas: ${queryStrings.length}`
  );
  console.log(`üìÅ Arquivo CSV com reposit√≥rios encontrados: ${csvPath}`);
  console.log(
    `=================================================================\n`
  );
  console.log(
    "üèÅ An√°lise conclu√≠da! Agora voc√™ pode executar as ferramentas nos reposit√≥rios encontrados."
  );
}

main();
