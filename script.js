const fetch = require('node-fetch');
const fs = require('fs');
require('dotenv').config();

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

if (!GITHUB_TOKEN) {
console.error('Erro: O token do GitHub n√£o foi encontrado. Certifique-se de que o arquivo .env cont√©m a vari√°vel GITHUB_TOKEN.');
process.exit(1);
}

const csvPath = 'repositorios_acessibilidade.csv';
const writeHeader = () => {
if (!fs.existsSync(csvPath)) {
fs.writeFileSync(
  csvPath,
  'Reposit√≥rio,Estrelas,AXE em Workflow,Pa11y em Workflow,Lighthouse em Workflow,Wave em Workflow,AXE em Depend√™ncia,Pa11y em Depend√™ncia,Lighthouse em Depend√™ncia,Wave em Depend√™ncia\n'
);
}
};

const appendToCSV = (row) => {
const line = `${row.nameWithOwner},${row.stars},${row.axe_wf},${row.pa11y_wf},${row.lighthouse_wf},${row.wave_wf},${row.axe_dep},${row.pa11y_dep},${row.lighthouse_dep},${row.wave_dep}\n`;
fs.appendFileSync(csvPath, line);
};

async function graphqlRequest(query, variables) {
const response = await fetch('https://api.github.com/graphql', {
method: 'POST',
headers: {
  Authorization: `Bearer ${GITHUB_TOKEN}`,
  'Content-Type': 'application/json',
},
body: JSON.stringify({ query, variables }),
});

if (!response.ok) {
throw new Error(`Erro na solicita√ß√£o GraphQL: ${response.statusText}`);
}

const data = await response.json();
return data.data;
}

async function fetchWithTimeout(url, options = {}, timeout = 30000) {
const controller = new AbortController();
const id = setTimeout(() => controller.abort(), timeout);
try {
const response = await fetch(url, { ...options, signal: controller.signal });
clearTimeout(id);
return response;
} catch (error) {
clearTimeout(id);
throw error;
}
}

async function checkWorkflows(owner, repo) {
const url = `https://api.github.com/repos/${owner}/${repo}/contents/.github/workflows`;
let axe = false, pa11y = false, lighthouse = false, wave = false;

try {
const response = await fetchWithTimeout(url, {
  headers: {
    Authorization: `Bearer ${GITHUB_TOKEN}`,
  },
});

if (response.status === 404) return { axe, pa11y, lighthouse, wave };
if (!response.ok) throw new Error(`Erro ao buscar workflows: ${response.statusText}`);

const files = await response.json();
if (!Array.isArray(files)) return { axe, pa11y, lighthouse, wave };

for (const file of files) {
  if (file.name.endsWith('.yml') || file.name.endsWith('.yaml')) {
    const workflowUrl = file.download_url;
    try {
      const workflowResponse = await fetchWithTimeout(workflowUrl, {}, 30000);
      if (!workflowResponse.ok) continue;
      const workflowContent = (await workflowResponse.text()).toLowerCase();
      if (workflowContent.includes('axe')) axe = true;
      if (workflowContent.includes('pa11y')) pa11y = true;
      if (workflowContent.includes('lighthouse')) lighthouse = true;
      if (workflowContent.includes('wave')) wave = true;
    } catch (error) {}
  }
}
return { axe, pa11y, lighthouse, wave };
} catch (error) {
return { axe, pa11y, lighthouse, wave };
}
}

async function checkDependencies(owner, repo) {
const dependencyFiles = ['package.json', 'requirements.txt', 'Gemfile', 'composer.json'];
let axe = false, pa11y = false, lighthouse = false, wave = false;

for (const fileName of dependencyFiles) {
const url = `https://api.github.com/repos/${owner}/${repo}/contents/${fileName}`;

try {
  const response = await fetchWithTimeout(url, {
    headers: {
      Authorization: `Bearer ${GITHUB_TOKEN}`,
    },
  });

  if (response.status === 404) continue;
  if (!response.ok) throw new Error(`Erro ao buscar arquivo ${fileName}: ${response.statusText}`);

  const file = await response.json();
  if (file.encoding === 'base64') {
    const content = Buffer.from(file.content, 'base64').toString('utf-8').toLowerCase();
    if (content.includes('axe')) axe = true;
    if (content.includes('pa11y')) pa11y = true;
    if (content.includes('lighthouse')) lighthouse = true;
    if (content.includes('wave')) wave = true;
  }
} catch (error) {
}
}
return { axe, pa11y, lighthouse, wave };
}

const searchRepositoriesQuery = `
query($queryString: String!, $first: Int!, $after: String) {
  search(query: $queryString, type: REPOSITORY, first: $first, after: $after) {
    repositoryCount
    edges {
      node {
        ... on Repository {
          name
          owner { login }
          stargazerCount
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
`;

async function main() {
  writeHeader();
  let totalFound = 0;
  let after = null;
  const batchSize = 100; // Aumentado para mais efici√™ncia
  const processedRepos = new Set(); // Para evitar duplicados

  const queryStrings = [
    // Queries principais - termos espec√≠ficos
    'axe-core sort:stars-desc',
    'pa11y sort:stars-desc',
    'lighthouse audit sort:stars-desc',
    'wave accessibility sort:stars-desc',
    
    // Queries mais amplas - t√≥picos
    'topic:accessibility sort:stars-desc',
    'topic:a11y sort:stars-desc',
    'topic:wcag sort:stars-desc',
    'topic:web-accessibility sort:stars-desc',
    
    // Queries de descri√ß√£o/readme - mais flex√≠veis
    'accessibility testing in:name,description,readme sort:stars-desc',
    'web accessibility in:name,description,readme sort:stars-desc',
    'accessibility automation in:name,description,readme sort:stars-desc',
    'accessibility audit in:name,description,readme sort:stars-desc',
    'accessibility tools in:name,description,readme sort:stars-desc',
    
    // Queries espec√≠ficas por ferramenta
    'axe testing sort:stars-desc',
    'pa11y testing sort:stars-desc', 
    'lighthouse accessibility sort:stars-desc',
    'wave automated testing sort:stars-desc',
    
    // Queries adicionais
    'aria testing sort:stars-desc',
    'screen reader testing sort:stars-desc',
    'accessibility compliance sort:stars-desc'
  ];

  for (const queryString of queryStrings) {
    after = null;
    let queryFound = 0;
    let queryAnalyzed = 0;
    console.log(`\nüîç Iniciando busca com query: "${queryString}"`);
    
    // Cada query roda at√© o final ou at√© 500 resultados por query
    while (queryFound < 500) {
      const variables = { queryString, first: batchSize, after };
      console.log(`üìä Buscando lote... Query: "${queryString.substring(0, 30)}..." | Encontrados nesta query: ${queryFound} | Total geral: ${totalFound}`);

      try {
        const data = await graphqlRequest(searchRepositoriesQuery, variables);
        const edges = data.search.edges;
        if (edges.length === 0) break;

        console.log(`üìà Total de reposit√≥rios dispon√≠veis para esta query: ${data.search.repositoryCount || 'N/A'}`);

        for (const edge of edges) {
          const repo = edge.node;
          const nameWithOwner = `${repo.owner.login}/${repo.name}`;

          // Pula se j√° foi processado
          if (processedRepos.has(nameWithOwner)) {
            console.log(`‚è≠Ô∏è  J√° processado anteriormente: ${nameWithOwner}`);
            continue;
          }

          // Remove filtro de estrelas que estava muito restritivo
          // Agora aceita qualquer n√∫mero de estrelas
          processedRepos.add(nameWithOwner);
          queryAnalyzed++;

          console.log(`üîç Analisando (${queryAnalyzed}): ${nameWithOwner} (${repo.stargazerCount}‚≠ê)`);

          const wf = await checkWorkflows(repo.owner.login, repo.name);
          const dep = await checkDependencies(repo.owner.login, repo.name);

          if (wf.axe || wf.pa11y || wf.lighthouse || wf.wave || dep.axe || dep.pa11y || dep.lighthouse || dep.wave) {
            appendToCSV({
              nameWithOwner,
              stars: repo.stargazerCount,
              axe_wf: wf.axe ? 'Sim' : 'N√£o',
              pa11y_wf: wf.pa11y ? 'Sim' : 'N√£o',
              lighthouse_wf: wf.lighthouse ? 'Sim' : 'N√£o',
              wave_wf: wf.wave ? 'Sim' : 'N√£o',
              axe_dep: dep.axe ? 'Sim' : 'N√£o',
              pa11y_dep: dep.pa11y ? 'Sim' : 'N√£o',
              lighthouse_dep: dep.lighthouse ? 'Sim' : 'N√£o',
              wave_dep: dep.wave ? 'Sim' : 'N√£o',
            });
            queryFound++;
            totalFound++;
            console.log(`‚úÖ Salvo no CSV! Query: ${queryFound} | Total: ${totalFound} | Repo: ${nameWithOwner}`);
          } else {
            console.log(`‚ùå Nenhuma ferramenta encontrada: ${nameWithOwner}`);
          }
        }

        if (!data.search.pageInfo.hasNextPage) {
          console.log(`üìÑ Sem mais p√°ginas para query: "${queryString.substring(0, 30)}..."`);
          break;
        }
        after = data.search.pageInfo.endCursor;

        // Pequena pausa para evitar rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000));

      } catch (error) {
        console.error(`‚ùå Erro na busca: ${error.message}`);
        await new Promise(resolve => setTimeout(resolve, 2000));
        break;
      }
    }

    console.log(`üìä Query finalizada: "${queryString.substring(0, 40)}..." | Encontrados: ${queryFound} | Analisados: ${queryAnalyzed}`);
    
    // Pausa entre queries
    await new Promise(resolve => setTimeout(resolve, 2000));
  }

  console.log(`\nüéâ ===== RESUMO FINAL DETALHADO ===== üéâ`);
  console.log(`üìä Total de reposit√≥rios √∫nicos analisados: ${processedRepos.size}`);
  console.log(`‚úÖ Total de reposit√≥rios com ferramentas de acessibilidade: ${totalFound}`);
  console.log(`üìà Taxa de sucesso: ${processedRepos.size > 0 ? ((totalFound / processedRepos.size) * 100).toFixed(2) : 0}%`);
  console.log(`üìÅ Arquivo CSV gerado: ${csvPath}`);
  console.log(`üîç Total de queries executadas: ${queryStrings.length}`);
  console.log(`=====================================\n`);
  console.log('üèÅ Processo finalizado!');
}

main();
